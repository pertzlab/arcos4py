"""Module to plot different metrics generated by arcos4py functions.

Examples:
    >>> # Data Plots
    >>> from arcos4py.plotting import dataPlots
    >>> data_plots = dataPlots(df,'time', 'meas', 'track_id')
    >>> hist = data_plots.histogram()
    >>> dens = data_plots.density_plot()
    >>> xt_plot = data_plots.position_t_plot({'x'}, n=20)

    >>> # Detrended vs original plot
    >>> from arcos4py.plotting import plotOriginalDetrended
    >>> arcosPlots = plotOriginalDetrended(data, 'time', 'meas', 'detrended', 'id')
    >>> plot = arcosPlots(data, 'time', 'meas', 'detrended', 'id')
    >>> plot.plot_detrended()

    >>> # Stats Plot
    >>> from arcos4py.plotting import statsPlots
    >>> coll_dur_size_scatter = statsPlots(stats).plot_events_duration('total_size','duration')

    >>> # Noodle Plot
    >>> from arcos4py.plotting import NoodlePlot
    >>> ndl = NoodlePlot(df,"collid", 'track_id', 'time', 'x', 'y')
    >>> ndl_plot = ndl.plot('x')
"""

from __future__ import annotations

import colorsys
import logging
from collections import defaultdict
from typing import TYPE_CHECKING, Any, Dict, List, Set, Tuple, Union

import matplotlib.patches as patches
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import seaborn as sns
from matplotlib.path import Path

if TYPE_CHECKING:
    from ..tools._detect_events import LineageTracker

from ..tools._arcos4py_deprecation import handle_deprecated_params

logging.basicConfig(level=logging.INFO)

TAB20 = [
    "#1f77b4",
    "#aec7e8",
    "#ff7f0e",
    "#ffbb78",
    "#2ca02c",
    "#98df8a",
    "#d62728",
    "#ff9896",
    "#9467bd",
    "#c5b0d5",
    "#8c564b",
    "#c49c94",
    "#e377c2",
    "#f7b6d2",
    "#7f7f7f",
    "#c7c7c7",
    "#bcbd22",
    "#dbdb8d",
    "#17becf",
    "#9edae5",
]


class dataPlots:
    """Plot different metrics of input data.

    Attributes:
        data (Dataframe): containing ARCOS data.
        frame_column (str): name of frame column in data.
        measurement_column (str): name of measurement column in data.
        obj_id_column (str): name of track id column.
    """

    def __init__(
        self,
        data: pd.DataFrame,
        frame_column: str = 'frame',
        measurement_column: str = 'm',
        obj_id_column: str = 'obj_id',
        **kwargs,
    ):
        """Plot different metrics such as histogram, position-t and density.

        Arguments:
            data (Dataframe): containing ARCOS data.
            frame_column (str): name of frame column in data.
            measurement_column (str): name of measurement column in data.
            obj_id_column (str): name of track id column.
            **kwargs (Any): Additional keyword arguments. Includes deprecated parameters.
                - id (str): Deprecated. Use obj_id_column instead.
                - frame (str): Deprecated. Use frame_column instead.
                - measurement (str): Deprecated. Use measurement_column instead.
        """
        map_deprecated_params = {
            "id": "obj_id_column",
            "frame": "frame_column",
            "measurement": "measurement_column",
        }

        # check allowed kwargs
        allowed_kwargs = map_deprecated_params.keys()
        for key in kwargs:
            if key not in allowed_kwargs:
                raise ValueError(f"Got an unexpected keyword argument '{key}'")

        updated_kwargs = handle_deprecated_params(map_deprecated_params, **kwargs)

        # Assigning the parameters
        obj_id_column = updated_kwargs.get("obj_id_column", obj_id_column)
        frame_column = updated_kwargs.get("frame_column", frame_column)
        measurement_column = updated_kwargs.get("measurement_column", measurement_column)

        self.data = data
        self.obj_id = obj_id_column
        self.frame_column = frame_column
        self.measurement_column = measurement_column

    def position_t_plot(self, position_columns: set[str] = {'x'}, n: int = 20, **kwargs) -> Union[plt.Figure, Any]:
        """Plots X and Y over T to visualize tracklength.

        Arguments:
            position_columns (set): containing names of position columns in data.
            n (int): number of samples to plot.
            **kwargs (Any): Additional keyword arguments. Includes deprecated parameters.
                - posCol (set): Deprecated. Use position_columns instead.

        Returns:
            fig (matplotlib.figure.Figure): Matplotlib figure object of density plot.
            axes (matplotlib.axes.Axes): Matplotlib axes of density plot.
        """
        map_deprecated_params = {
            "posCol": "position_columns",
        }

        # check allowed kwargs
        allowed_kwargs = map_deprecated_params.keys()
        for key in kwargs:
            if key not in allowed_kwargs:
                raise ValueError(f"Got an unexpected keyword argument '{key}'")

        updated_kwargs = handle_deprecated_params(map_deprecated_params, **kwargs)

        # Assigning the parameters
        position_columns = updated_kwargs.get("position_columns", position_columns)

        sample = pd.Series(self.data[self.obj_id].unique()).sample(n)
        pd_from_r_df = self.data.loc[self.data[self.obj_id].isin(sample)]
        fig, axes = plt.subplots(1, len(position_columns), figsize=(6, 3))
        for _, df in pd_from_r_df.groupby(self.obj_id):
            for index, value in enumerate(position_columns):
                if len(position_columns) > 1:
                    df.plot(x=self.frame_column, y=value, ax=axes[index], legend=None)
                else:
                    df.plot(x=self.frame_column, y=value, ax=axes, legend=None)
        if len(position_columns) > 1:
            for index, value in enumerate(position_columns):
                axes[index].set_title(value)
        else:
            axes.set_title(value)
        return fig, axes

    def density_plot(self, *args, **kwargs):
        """Density plot of measurement.

        Uses Seaborn distplot to plot measurement density.

        Arguments:
            *args (Any): arguments passed on to seaborn histplot function.
            **kwargs (Any): keyword arguments passed on to seaborn histplot function.

        Returns:
            FacetGrid (seaborn.FacetGrid): Seaborn FacetGrid of density density plot.
        """
        plot = sns.displot(
            self.data[self.measurement_column],
            kind="kde",
            palette="pastel",
            label=self.measurement_column,
            *args,
            **kwargs,
        )
        # Plot formatting
        plt.legend(prop={'size': 10})
        plt.title('Density Plot of Measurement')
        plt.xlabel('Measurement')
        plt.ylabel('Density')
        return plot

    def histogram(self, bins: str = 'auto', *args, **kwargs) -> plt.Axes:
        """Histogram of tracklenght.

        Uses seaborn histplot function to plot tracklenght histogram.

        Arguments:
            bins (str): number or width of bins in histogram
            *args (Any): arguments passed on to seaborn histplot function.
            **kwargs (Any): keyword arguments passed on to seaborn histplot function.

        Returns:
            AxesSubplot: Matplotlib AxesSubplot of histogram.
        """
        # Draw histogram
        track_length = self.data.groupby(self.obj_id).size()
        axes = sns.histplot(track_length, label="Track Length", bins=bins, *args, **kwargs)
        # Plot formatting
        plt.title('Track length Histogram')
        axes.set_xlabel('Track Length')
        axes.set_ylabel('Count')
        return axes


class plotOriginalDetrended:
    """Plot original and detrended data.

    Attributes:
        data (DataFrame): containing ARCOS data.
        frame_column (str): name of frame column in data.
        measurement_column (str): name of measurement column in data.
        detrended_column (str): name of detrended column in data.
        obj_id_column (str): name of track id column.
        seed (int): seed for random number generator.

    Methods:
        plot_detrended: plot detrended data.
        plot_original: plot original data.
        plot_original_and_detrended: plot original and detrended data.
    """

    def __init__(
        self,
        data: pd.DataFrame,
        frame_column: str = "frame",
        measurement_column: str = "m",
        detrended_column: str = "m_detrended",
        obj_id_column: str = "obj_id",
        seed: int = 42,
        **kwargs,
    ):
        """Constructs class with given parameters."""
        map_deprecated_params = {
            "id": "obj_id_column",
            "frame": "frame_column",
            "detrended": "detrended_column",
            "measurement": "measurement_column",
        }

        # check allowed kwargs
        allowed_kwargs = map_deprecated_params.keys()
        for key in kwargs:
            if key not in allowed_kwargs:
                raise ValueError(f"Got an unexpected keyword argument '{key}'")

        updated_kwargs = handle_deprecated_params(map_deprecated_params, **kwargs)

        # Assigning the parameters
        obj_id_column = updated_kwargs.get("obj_id_column", obj_id_column)
        frame_column = updated_kwargs.get("frame_column", frame_column)
        measurement_column = updated_kwargs.get("measurement_column", measurement_column)

        self.data = data
        self.frame_column = frame_column
        self.measurement_column = measurement_column
        self.detrended_column = detrended_column
        self.obj_id_column = obj_id_column
        self.seed = seed

    def _prepare_data(self, n_samples: int):
        rng_gen = np.random.default_rng(seed=self.seed)
        vals = rng_gen.choice(self.data[self.obj_id_column].unique(), n_samples, replace=False)  # noqa: F841
        filtered_data = self.data.query(f"{self.obj_id_column} in @vals")
        return filtered_data.groupby(self.obj_id_column)

    def _plot_data(self, grouped, ncols, nrows, plotsize, plot_columns, labels, add_binary_segments=False):
        fig, axes2d = plt.subplots(nrows=nrows, ncols=ncols, figsize=plotsize, sharey=True)
        max_val = 0
        for (name, group), ax in zip(grouped, axes2d.flatten()):
            for column, label in zip(plot_columns, labels):
                ax.plot(group[self.frame_column], group[column], label=label)
                max_val = group[column].max() if group[column].max() > max_val else max_val
            ax.set_title(f"Track {name}")

        if add_binary_segments:
            for (name, group), ax in zip(grouped, axes2d.flatten()):
                self._add_binary_segments(group, ax, max_val)

        fig.supxlabel('Time Point')
        fig.supylabel('Measurement')
        handles, labels = ax.get_legend_handles_labels()
        fig.tight_layout()
        fig.legend(handles, labels, loc='upper right')

        return fig, axes2d

    def _add_binary_segments(self, group, ax, max_val):
        x_val = group[group[f"{self.measurement_column}.bin"] != 0][self.frame_column]
        y_val = np.repeat(max_val, x_val.size)
        indices = np.where(np.diff(x_val) != 1)[0] + 1
        x_split = np.split(x_val, indices)
        y_split = np.split(y_val, indices)
        for idx, (x_val, y_val) in enumerate(zip(x_split, y_split)):
            if idx == 0:
                ax.plot(x_val, y_val, color="red", lw=2, label="bin")
            else:
                ax.plot(x_val, y_val, color="red", lw=2)

    def plot_detrended(
        self,
        n_samples: int = 25,
        subplots: tuple = (5, 5),
        plotsize: tuple = (20, 10),
        add_binary_segments: bool = False,
    ) -> tuple[plt.Figure, Any]:
        """Plots detrended data.

        Arguments:
            n_samples (int): number of samples to plot.
            subplots (tuple): number of subplots in x and y direction.
            plotsize (tuple): size of the plot.
            add_binary_segments (bool): if True, binary segments are added to the plot.

        Returns:
            fig (matplotlib.figure.Figure): Matplotlib figure object of plot.
            axes (matplotlib.axes.Axes): Matplotlib axes of plot.
        """
        grouped = self._prepare_data(n_samples)
        return self._plot_data(
            grouped, subplots[0], subplots[1], plotsize, [self.detrended_column], ["detrended"], add_binary_segments
        )

    def plot_original(
        self,
        n_samples: int = 25,
        subplots: tuple = (5, 5),
        plotsize: tuple = (20, 10),
        add_binary_segments: bool = False,
    ) -> tuple[plt.Figure, Any]:
        """Plots original data.

        Arguments:
            n_samples (int): number of samples to plot.
            subplots (tuple): number of subplots in x and y direction.
            plotsize (tuple): size of the plot.
            add_binary_segments (bool): if True, binary segments are added to the plot.

        Returns:
            fig (matplotlib.figure.Figure): Matplotlib figure object of plot.
            axes (matplotlib.axes.Axes): Matplotlib axes of plot.
        """
        grouped = self._prepare_data(n_samples)
        return self._plot_data(
            grouped,
            subplots[0],
            subplots[1],
            plotsize,
            [self.measurement_column],
            ["original"],
            add_binary_segments,
        )

    def plot_original_and_detrended(
        self,
        n_samples: int = 25,
        subplots: tuple = (5, 5),
        plotsize: tuple = (20, 10),
        add_binary_segments: bool = False,
    ) -> tuple[plt.Figure, Any]:
        """Plots original and detrended data.

        Arguments:
            n_samples (int): number of samples to plot.
            subplots (tuple): number of subplots in x and y direction.
            plotsize (tuple): size of the plot.
            add_binary_segments (bool): if True, binary segments are added to the plot.

        Returns:
            fig (matplotlib.figure.Figure): Matplotlib figure object of plot.
            axes (matplotlib.axes.Axes): Matplotlib axes of plot.
        """
        grouped = self._prepare_data(n_samples)
        return self._plot_data(
            grouped,
            subplots[0],
            subplots[1],
            plotsize,
            [self.measurement_column, self.detrended_column],
            ["original", "detrended"],
            add_binary_segments,
        )


class statsPlots:
    """Plot data generated by the stats module.

    Attributes:
        data (DataFrame): containing ARCOS stats data.
    """

    def __init__(self, data: pd.DataFrame):
        """Plot detrended vs original data.

        Arguments:
            data (DataFrame): containing ARCOS stats data.
        """
        self.data = data

    def plot_events_duration(self, total_size: str, duration: str, point_size: int = 40, *args, **kwargs) -> plt.Axes:
        """Scatterplot of collective event duration.

        Arguments:
            total_size (str): name of total size column.
            duration (str):, name of column with collective event duration.
            point_size (int): scatterplot point size.
            *args (Any): Arguments passed on to seaborn scatterplot function.
            **kwargs (Any): Keyword arguments passed on to seaborn scatterplot function.

        Returns:
            Axes (matplotlib.axes.Axes): Matplotlib Axes object of scatterplot
        """
        if self.data.empty:
            raise ValueError("Dataframe is empty")
        plot = sns.scatterplot(x=self.data[total_size], y=self.data[duration], s=point_size, *args, **kwargs)
        return plot


class NoodlePlot:
    """Create Noodle Plot of cell tracks, colored by collective event id.

    Attributes:
        df (pd.DataFrame): DataFrame containing collective events from arcos.
        colev (str): Name of the collective event column in df.
        trackid (str): Name of the track column in df.
        frame (str): Name of the frame column in df.
        posx (str): Name of the X coordinate column in df.
        posy (str): Name of the Y coordinate column in df.
        posz (str): Name of the Z coordinate column in df,
            or None if no z column.
    """

    def __init__(
        self,
        df: pd.DataFrame,
        clid_column: str = "collid",
        obj_id_column: str = "obj_id",
        frame_column: str = "frame",
        posx: str = "x",
        posy: str = "y",
        posz: Union[str, None] = None,
        **kwargs,
    ):
        """Constructs class with given parameters.

        Arguments:
            df (pd.DataFrame): DataFrame containing collective events from arcos.
            clid_column (str): Name of the collective event column in df.
            obj_id_column (str): Name of the track column in df.
            frame_column (str): Name of the frame column in df.
            posx (str): Name of the X coordinate column in df.
            posy (str): Name of the Y coordinate column in df.
            posz (str | None): Name of the Z coordinate column in df,
                or None if no z column.
            **kwargs (Any): Additional keyword arguments for plot. Includes deprecated parameters.
                - colev (str): Deprecated. Use clid_column instead.
                - trackid (str): Deprecated. Use obj_id_column instead.
                - frame (str): Deprecated. Use frame_column instead.
        """
        map_deprecated_params = {
            "colev": "clid_column",
            "trackid": "obj_id_column",
            "frame": "frame_column",
        }

        # allowed matplotlib kwargs
        allowed_kwargs = [
            "alpha",
            "animated",
            "c",
            "label",
            "linewidth",
            "linestyle",
            "marker",
            "markersize",
            "markeredgecolor",
            "markerfacecolor",
            "markerfacecoloralt",
            "markeredgewidth",
            "path_effects",
            "picker",
            "pickradius",
            "solid_capstyle",
            "solid_joinstyle",
            "transform",
            "visible",
            "zorder",
        ]

        # check allowed kwargs
        allowed_kwargs_2 = map_deprecated_params.keys()
        for key in kwargs:
            if key not in allowed_kwargs and key not in allowed_kwargs_2:
                raise ValueError(f"Got an unexpected keyword argument '{key}'")

        updated_kwargs = handle_deprecated_params(map_deprecated_params, **kwargs)

        # Assigning the parameters
        clid_column = updated_kwargs.pop("clid_column", clid_column)
        obj_id_column = updated_kwargs.pop("obj_id_column", obj_id_column)
        frame_column = updated_kwargs.pop("frame_column", frame_column)

        self.df = df
        self.clid_column = clid_column
        self.obj_id_column = obj_id_column
        self.frame_column = frame_column
        self.posx = posx
        self.posy = posy
        self.posz = posz
        self.plot_kwargs = updated_kwargs

    def _prepare_data_noodleplot(
        self,
        df: pd.DataFrame,
        color_cylce: list[str],
        clid_column: str,
        obj_id_column: str,
        frame_column: str,
        posx: str,
        posy: str,
        posz: Union[str, None] = None,
    ) -> tuple[list[np.ndarray], np.ndarray]:
        """From arcos collective event data,\
        generates a list of numpy arrays, one for each event.

        Arguments:
            df (pd.DataFrame): DataFrame containing collective events from arcos.
            color_cylce (list[str]): list of colors used to color trackid's
                for individual collective events.
            colev (str): Name of the collective event column in df.
            trackid (str): Name of the track column in df.
            frame: (str): Name of the frame column in df.
            posx (str): Name of the X coordinate column in df.
            posy (str): Name of the Y coordinate column in df.
            posz (str): Name of the Z coordinate column in df,
                or None if no z column.

        Returns:
            grouped_array (list[np.ndarray]): List of collective events data
            colors (np.ndarray): colors for each collective event.
        """
        df = df.copy()
        # factorize trackid to get unique values and make sure they are nummeric
        df[obj_id_column] = df[obj_id_column].factorize()[0]
        # sort by collective event and trackid
        df = df.sort_values([clid_column, obj_id_column])
        if posz:
            array = df[[clid_column, obj_id_column, frame_column, posx, posy, posz]].to_numpy()
        else:
            array = df[[clid_column, obj_id_column, frame_column, posx, posy]].to_numpy()
        # generate goroups for each unique value
        grouped_array = np.split(array, np.unique(array[:, 0], axis=0, return_index=True)[1][1:])
        # make collids sequential
        seq_colids = np.concatenate(
            [np.repeat(i, value.shape[0]) for i, value in enumerate(grouped_array)],
            axis=0,
        )
        array_seq_colids = np.column_stack((array, seq_colids))
        # split sequential collids array by trackid and collid
        grouped_array = np.split(
            array_seq_colids,
            np.unique(array_seq_colids[:, :2], axis=0, return_index=True)[1][1:],
        )
        # generate colors for each collective event, wrap arround the color cycle
        colors = np.take(np.array(color_cylce), [i + 1 for i in np.unique(seq_colids)], mode="wrap")
        return grouped_array, colors

    def _create_noodle_plot(self, grouped_data: list[np.ndarray], colors: np.ndarray):
        """Plots the noodle plot."""
        fig, ax = plt.subplots()
        ax.set_xlabel("Time Point")
        ax.set_ylabel("Position")
        for dat in grouped_data:
            if dat.size == 0:
                continue
            ax.plot(
                dat[:, 2],
                dat[:, self.projection_index],
                c=colors[int(dat[0, -1])],
                **self.plot_kwargs,
            )
        return fig, ax

    def plot(self, projection_axis: str, color_cylce: list[str] = TAB20):
        """Create Noodle Plot of cell tracks, colored by collective event id.

        Arguments:
            projection_axis (str): Specify with witch coordinate the noodle
                plot should be drawn. Has to be one of the posx, posy or posz arguments
                passed in during the class instantiation process.
            color_cylce (list[str]): List of hex color values or string names
                (i.e. ['red', 'yellow']) used to color collecitve events. Cycles through list.

        Returns:
            fig (matplotlib.figure.Figure): Matplotlib figure object for the noodle plot.
            axes (matplotlib.axes.Axes): Matplotlib axes for the nooble plot.
        """
        if projection_axis not in [self.posx, self.posy, self.posz]:
            raise ValueError(f"projection_axis has to be one of {[self.posx, self.posy, self.posz]}")
        if projection_axis == self.posx:
            self.projection_index = 3
        elif projection_axis == self.posy:
            self.projection_index = 4
        elif projection_axis == self.posz:
            self.projection_index = 5
        if self.df.empty:
            grpd_data: list[np.ndarray] = []
            colors: np.ndarray = np.array([])
        else:
            grpd_data, colors = self._prepare_data_noodleplot(
                self.df,
                color_cylce,
                self.clid_column,
                self.obj_id_column,
                self.frame_column,
                self.posx,
                self.posy,
                self.posz,
            )
        fig, axes = self._create_noodle_plot(grpd_data, colors)
        return fig, axes


class LineagePlot:
    """Class to draw a lineage tree of clusters over time.

    Attributes:
        figsize (tuple): Size of the figure.
        node_size (int): Size of the nodes.
        draw_nodes (bool): If True, draw nodes.
        edge_width (int): Width of the edges.
        edge_alpha (float): Alpha value of the edges.
        color_seed (int): Seed for the color generation.
        title (str): Title of the plot.
        xlabel (str): Label of the x-axis.
        ylabel (str): Label of the y-axis.
        font_size (int): Font size of the labels.
        curve_factor (float): Factor to curve the edges.
        orphan_color (tuple): Color of the orphan nodes.
    """
    def __init__(
        self,
        figsize=(18, 18),
        node_size=50,
        draw_nodes=False,
        edge_width=2,
        edge_alpha=0.8,
        color_seed=42,
        title="Cluster Lineage Tree",
        xlabel="Frame",
        ylabel="Cluster",
        font_size=16,
        curve_factor=0.9,
        orphan_color=(0.7, 0.7, 0.7, 1.0),
    ):
        """Constructs class with given parameters.

        Arguments:
            figsize (tuple): Size of the figure.
            node_size (int): Size of the nodes.
            draw_nodes (bool): If True, draw nodes.
            edge_width (int): Width of the edges.
            edge_alpha (float): Alpha value of the edges.
            color_seed (int): Seed for the color generation.
            title (str): Title of the plot.
            xlabel (str): Label of the x-axis.
            ylabel (str): Label of the y-axis.
            font_size (int): Font size of the labels.
            curve_factor (float): Factor to curve the edges.
            orphan_color (tuple): Color of the orphan nodes.
        """
        # Initialization code remains the same
        self.fig, self.ax = plt.subplots(figsize=figsize)
        self.node_size = node_size
        self.edge_width = edge_width
        self.edge_alpha = edge_alpha
        self.title = title
        self.xlabel = xlabel
        self.ylabel = ylabel
        self.font_size = font_size
        self.curve_factor = curve_factor
        self.orphan_color = orphan_color
        self.draw_nodes = draw_nodes
        self.color_seed = color_seed

        self.lineage_colors: Dict[int, Tuple[float, float, float, float]] = {}
        self.node_positions: Dict[Tuple[int, int], Tuple[float, float]] = {}
        self.lineage_edges: List[Tuple[Tuple[int, int], Tuple[int, int]]] = []
        self.node_lineage_color: Dict[Tuple[int, int], Tuple[float, float, float, float]] = {}
        self.child_to_parent: Dict[Tuple[int, int], Set[Tuple[int, int]]] = {}
        self.parent_to_child: Dict[Tuple[int, int], Set[Tuple[int, int]]] = {}
        self.lineage_order: List[int] = []
        self.all_nodes: Set[Tuple[int, int]] = set()
        self.frame_to_nodes: Dict[int, List[Tuple[int, int]]] = defaultdict(list)

    def _process_data(self, tracker: LineageTracker):
        # Initialize data structures
        self.all_nodes = set()
        self.frame_to_nodes = defaultdict(list)
        self.parent_to_child = {}
        self.child_to_parent = {}
        self.lineage_edges = []
        self.minframe_nodes = set()

        # Expand nodes and edges based on parent-child relationships over time
        for node in tracker.nodes.values():
            # Add edges within the same cluster over consecutive frames
            for frame in range(node.minframe, node.maxframe):
                source = (frame, node.cluster_id)
                target = (frame + 1, node.cluster_id)
                self.lineage_edges.append((source, target))
                self.all_nodes.add(source)
                self.all_nodes.add(target)
                self.parent_to_child.setdefault(source, set()).add(target)
                self.child_to_parent.setdefault(target, set()).add(source)

            # Track node persistence across frames
            for frame in range(node.minframe, node.maxframe + 1):
                current_node = (frame, node.cluster_id)
                self.all_nodes.add(current_node)
                self.frame_to_nodes[frame].append(current_node)
                # Add to minframe_nodes if it's the first frame
                if frame == node.minframe:
                    self.minframe_nodes.add(current_node)

            # Add edges between parent and child clusters
            child_start_frame = node.minframe
            child_node = (child_start_frame, node.cluster_id)
            for parent in node.parents:
                parent_end_frame = parent.maxframe
                parent_node = (parent_end_frame, parent.cluster_id)
                self.lineage_edges.append((parent_node, child_node))
                self.parent_to_child.setdefault(parent_node, set()).add(child_node)
                self.child_to_parent.setdefault(child_node, set()).add(parent_node)

        # Assign colors based on lineage_id
        self._assign_lineage_colors(tracker)
        self._order_clusters_by_relationships()

        # Position nodes
        cluster_id_to_y = {cluster_id: idx for idx, cluster_id in enumerate(self.lineage_order)}
        max_idx = len(cluster_id_to_y) - 1
        self.node_positions = {}
        for node_tuple in self.all_nodes:
            frame, cluster_id = node_tuple
            x = frame
            y = cluster_id_to_y[cluster_id] / max_idx if max_idx > 0 else 0.5
            self.node_positions[node_tuple] = (x, y)

    def _assign_lineage_colors(self, tracker: LineageTracker):
        # Collect unique lineage IDs
        unique_lineages = {node.lineage_id for node in tracker.nodes.values()}

        # Generate a color for each unique lineage
        lineage_colors = self._generate_colors(len(unique_lineages))
        lineage_color_map = dict(zip(unique_lineages, lineage_colors))

        # Assign colors to nodes based on their lineage_id
        for node in tracker.nodes.values():
            color = lineage_color_map.get(node.lineage_id, self.orphan_color)
            for frame in range(node.minframe, node.maxframe + 1):
                self.node_lineage_color[(frame, node.cluster_id)] = color

        # Assign orphan color to any node without lineage
        for node_tuple in self.all_nodes:
            if node_tuple not in self.node_lineage_color:
                self.node_lineage_color[node_tuple] = self.orphan_color

    def _order_clusters_by_relationships(self):
        cluster_adjacency = defaultdict(set)
        for edge in self.lineage_edges:
            source_cluster_id = edge[0][1]
            target_cluster_id = edge[1][1]
            if source_cluster_id != target_cluster_id:
                cluster_adjacency[source_cluster_id].add(target_cluster_id)
                cluster_adjacency[target_cluster_id].add(source_cluster_id)

        cluster_degrees = {cluster_id: len(neighbors) for cluster_id, neighbors in cluster_adjacency.items()}
        weighted_degrees = {}
        for cluster_id, neighbors in cluster_adjacency.items():
            weighted_degrees[cluster_id] = sum(cluster_degrees[neighbor] for neighbor in neighbors)

        all_cluster_ids = set(cluster_id for _, cluster_id in self.all_nodes)
        unvisited_clusters = set(all_cluster_ids)

        start_cluster = max(weighted_degrees, key=weighted_degrees.get) if weighted_degrees else min(all_cluster_ids)

        self.lineage_order = []
        visited_clusters = set()

        def _add_cluster(cluster):
            self.lineage_order.append(cluster)
            visited_clusters.add(cluster)
            unvisited_clusters.discard(cluster)

        _add_cluster(start_cluster)

        while unvisited_clusters:
            candidates = []
            for cluster_id in unvisited_clusters:
                connections = len(cluster_adjacency.get(cluster_id, set()) & visited_clusters)
                weighted_connections = sum(
                    cluster_degrees.get(c, 0) for c in (cluster_adjacency.get(cluster_id, set()) & visited_clusters)
                )
                candidates.append((cluster_id, connections, weighted_connections, weighted_degrees.get(cluster_id, 0)))

            if candidates:
                next_cluster = max(candidates, key=lambda x: (x[1], x[2], x[3]))[0]
            else:
                next_cluster = max(unvisited_clusters, key=lambda x: weighted_degrees.get(x, 0))

            _add_cluster(next_cluster)

        return self.lineage_order

    def _generate_colors(self, n: int) -> List[Tuple[float, float, float, float]]:
        colors = []
        rng = np.random.default_rng(self.color_seed)
        for i in range(n):
            colors.append((*colorsys.hsv_to_rgb(rng.random(), 0.8, 0.8), 1.0))
        return colors

    def _draw_curved_edge(self, start, end, color):
        """Draw a curved edge between two points, with color."""
        mid_x = (start[0] + end[0]) / 2
        mid_y1 = start[1] + (end[1] - start[1]) * self.curve_factor
        mid_y2 = end[1] - (end[1] - start[1]) * self.curve_factor
        path = Path(
            [start, (mid_x, mid_y1), (mid_x, mid_y2), end], [Path.MOVETO, Path.CURVE4, Path.CURVE4, Path.CURVE4]
        )
        patch = patches.PathPatch(
            path, facecolor="none", edgecolor=color, alpha=self.edge_alpha, linewidth=self.edge_width
        )
        self.ax.add_patch(patch)

    def draw_tree(self, tracker: LineageTracker):
        """Draw the lineage tree based on the processed data."""
        self._process_data(tracker)

        # Draw edges with lineage-based coloring
        for source, target in self.lineage_edges:
            source_pos = self.node_positions[source]
            target_pos = self.node_positions[target]
            color = self.node_lineage_color.get(source, self.orphan_color)
            self._draw_curved_edge(source_pos, target_pos, color)

        # Draw nodes if required
        if self.draw_nodes:
            for node in self.minframe_nodes:
                pos = self.node_positions[node]
                color = self.node_lineage_color.get(node, self.orphan_color)
                self.ax.scatter(pos[0], pos[1], s=self.node_size, c=[color], zorder=2)

        # Set labels and title
        self.ax.set_title(self.title, fontsize=self.font_size)
        self.ax.set_xlabel(self.xlabel, fontsize=self.font_size - 2)
        self.ax.set_ylabel(self.ylabel, fontsize=self.font_size - 2)

        # Set y-ticks to cluster IDs
        cluster_ids = self.lineage_order
        cluster_id_to_y = {cluster_id: idx for idx, cluster_id in enumerate(cluster_ids)}
        max_idx = len(cluster_ids) - 1
        y_ticks = [cluster_id_to_y[cluster_id] / max_idx if max_idx > 0 else 0.5 for cluster_id in cluster_ids]
        self.ax.set_yticks(y_ticks)
        self.ax.set_yticklabels(cluster_ids, fontsize=self.font_size - 4)
        plt.tight_layout()

    def show(self):
        """Display the plot."""
        plt.show()
